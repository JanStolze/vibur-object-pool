<wiki:comment>
  Copyright 2013 Simeon Malchev

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
</wiki:comment>

== Quick Introduction ==

Vibur Object Pool is a general-use concurrent Java object pool which provides
both non-validating and validating pool implementations. The pool is built
entirely using the standard Java concurrent utilities, does not use any direct synchronization,
and does not have any external dependencies. This pool is an excellent choice for pooling/caching
of expensive to create Java objects such as database connections, JMS connections/sessions and similar.

Vibur Object Pool is utilised by [https://code.google.com/p/vibur-dbcp/ Vibur DBCP]
(a JDBC connection pool).

==== _Non-validating_ object pool: ====

The implementation of the _non-validating_ object pool (_ConcurrentLinkedPool_)
is based on a _ConcurrentLinkedQueue_ and a _Semaphore_. This pool does *not*
implement any validation of whether the currently restored object has been taken
before that from the pool, or whether the object is currently in taken state.

The _non-validating_ object pool provides support for fairness with regards to the waiting
taker's threads. The creation of new objects in the pool and their lifecycle are controlled
by the provided during the pool's creation time _PoolObjectFactory_.

The _non-validating_ object pool provides support for shrinking (reduction) of the number
of allocated on the pool objects, and the developer has full control over it via the
_reduceCreated(int)_ pool method and the _PoolReducer_ util class.

==== _Validating_ object pool: ====

The implementation of the _validating_ object pool (_ConcurrentHolderLinkedPool_)
is built (composed) using a _non-validating ConcurrentLinkedPool_ and is utilising
a _ConcurrentHashMap_ for the validation of the restored objects. The validation checks
whether the currently restored object holder has been taken before that from the pool,
and whether it is currently in taken state.

The _validating_ object pool _take_ methods are returning the pool's objects enclosed
in a thin wrapper class implementing the _Holder_ interface. The underlying object is
accessible via the interface's _value()_ method.

The _validating_ object pool provides support for fairness with regards to the waiting
taker's threads in the same way as it is provided by the underlying _ConcurrentLinkedPool_.

The _validating_ object pool has support for automated shrinking (reduction) of the number of
allocated on the pool objects. Again, this functionality is built on top of the one provided
by the underlying _ConcurrentLinkedPool_.

== Usage Examples ==

====Maven dependency:====

  * coming soon...

{{{
HolderValidatingPoolService<Object> chlp = new ConcurrentHolderLinkedPool<Object>(
        new SimpleObjectFactory(), 10, 60, false);
Holder<Object> hobj = null;
try {
    hobj = chlp.tryTake();

    // do some work and use hobj.value()

} finally {
    if (hobj != null)
        chlp.restore(hobj);
}
}}}

More usage examples can be found in the project's unit tests folder.
