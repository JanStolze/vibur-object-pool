<wiki:comment>
  Copyright 2013 Simeon Malchev

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
</wiki:comment>

=== Vibur Object Pool ===

Vibur Object Pool is a general-use concurrent Java object pool which provides
both validating and non-validating pool implementations. The pool is built
entirely using the standard Java concurrency utilities, does not use any synchronized blocks/methods,
and does not have any external dependencies. This pool is an excellent choice for pooling/caching
of expensive to create Java objects such as database connections (or other socket connections to remote hosts)
and similar. The pool is utilised by [https://code.google.com/p/vibur-dbcp/ Vibur DBCP], a JDBC connection pool.

  # [#Quick_Introduction Quick Introduction]
  # [#Usage_Examples Usage Examples]
    * [#Maven_dependency: Maven Dependency]
    * [#Programming_example: Programming Example]
  # [#Latest_Version_&_How_to_Build Latest Version & How to Build]
  # [#Development_Team Development Team]


=== Quick Introduction ===

==== Concurrency and performance bounds: =====

In the terms of standard Java concurrency utilities, the non-validating object pool `take` and `restore`
operations performance is bound by the same of a `ConcurrentLinkedQueue's` `poll` and `add` operations, where the
CLQ is additionally guarded by a `Semaphore`, which fairness parameter is set to `true` or `false` depending on the
pool's such. The validating pool performance incurs an additional `put` and a `remove` operations from a
`ConcurrentHashMap`. While both pools employ some little additional logic for various house-keeping purposes,
their overall performance remains function of the aforementioned standard concurrency utilities.

==== Non-validating object pool: ====

The implementation of the non-validating object pool (`ConcurrentLinkedPool`)
is based on a `ConcurrentLinkedQueue` and a `Semaphore`. This pool does *not*
implement any validation of whether the currently restored object has been taken
before that from the pool, or whether the object is currently in taken state.

The non-validating object pool provides support for fairness with regards to the waiting
taker's threads. The creation of new objects in the pool and their lifecycle are controlled
by the provided during the pool's creation time `PoolObjectFactory`.

The non-validating object pool provides support for manual or automated shrinking (reduction)
of the allocated on the pool objects, and the developer has full control over it
via the `reduceCreated(int)` pool method and the `SamplingPoolReducer` utilily class.

==== Validating object pool: ====

The validating object pool (`ConcurrentHolderLinkedPool`) is implemented (composed) using a
non-validating `ConcurrentLinkedPool` and a `ConcurrentHashMap` for the validation
of the restored objects. The validation checks whether the currently restored object holder has
been taken before that from the pool, and whether it is currently in taken state.

The validating object pool `take` methods are returning the pool's objects enclosed
in a thin wrapper class implementing the `Holder` interface. The underlying object is
accessible via the interface's `value()` method.

The validating object pool provides support for fairness with regards to the waiting
taker's threads in the same way as it is provided by the underlying `ConcurrentLinkedPool`.

The validating object pool has support for manual or automated shrinking (reduction)
of the allocated on the pool objects. Again, this functionality is built on
top of the same provided by the underlying `ConcurrentLinkedPool`.


<br/>
=== Usage Examples ===

==== Maven dependency: ====

  * coming soon...

==== Programming example: ====

{{{
HolderValidatingPoolService<SomeClass> pool = new ConcurrentHolderLinkedPool<SomeClass>(
        new SomeClassFactory(), 10, 60, false);

//...

Holder<SomeClass> hObj = null;
try {
    hObj = pool.tryTake(10, TimeUnit.SECONDS);
    if (hObj == null) // i.e. no any object was available in the pool for 10 seconds
        return;

    // do some work and use hObj.value()

} finally {
    if (hObj != null)
        pool.restore(hObj, true);
}
}}}

More usage examples can be found in the project's unit tests folder.


=== Latest Version & How to Build ===

Vibur Object Pool latest version is 0.8.9. Maven dependency example for it is shown [#Maven_dependency: above].
A read-only copy of the source code can be checked out via:

  `svn checkout http://vibur-object-pool.googlecode.com/svn/tags/0.8.9 vibur-object-pool-0.8.9`

Building it is simply a matter of executing:

  `mvn clean install`


===Development Team===

Vibur Object Pool is designed, developed and provided to you by Simeon Malchev (firstname.lastname at gmail.com).
If you need to report any bugs or issues, or if you just wish to provide some general feedback, please use the
project's issues tracking [https://code.google.com/p/vibur-object-pool/issues/list system] or the author's email.
